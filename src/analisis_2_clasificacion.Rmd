---
title: "Clasificacion NET PROMOTER"
author: "Izaskun Lopez-Samaniego"
date: "9 de julio de 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
require("knitr")
opts_knit$set(root.dir="./")

```

## Preparación del entorno


```{r entorno}
library(data.table)
library(caret)

ruta <-'C:/Users/izask/Modelo Parking/Modelo Parkings/src'
setwd(ruta)

source('./R_funciones.R')


t.parkings.analizar <- as.data.table(read.csv('../dat/datos_parkings.csv',
                       sep = ';', dec = ',',header = TRUE))
t.parkings.analizar <- t.parkings.analizar[,-c('Id_parking',
                                               'monthly.ingresos.log')]
t.parkings.analizar <- na.omit(t.parkings.analizar)

```


## Dividimos la muestra en casos de test y casos de training

```{r test and testing, echo=FALSE}

inTrain <- sample(1:nrow(t.parkings.analizar),
                  nrow(t.parkings.analizar)*0.3)

train.NPS  <- t.parkings.analizar[-inTrain,]
test.NPS   <- t.parkings.analizar[inTrain,]

```


#CLASIFICACIÓN CON ANÁLISIS DISCRIMINANTE

1. LDA: Buscamos un modelo basado en relaciones lineales

  - La clasificación no se ejecuta correctamente.

```{r LDA, echo=FALSE}

#LDA.fit <- train(desc.NPS~., 
#                 method='lda',
#                 data=train.NPS)
#print(LDA.fit)

#confusionMatrix(test.NPS$desc.NPS, predict(LDA.fit, test.NPS))

```


2. QDA: Buscamos un modelo basado en relaciones no lineales (cuadraticas)

  - La muestra es pequeña y el modelo no se ejecuta correctamente


```{r QDA, echo=FALSE}
#QDA.fit<- train(desc.NPS~., 
#                 method='qda',
#                 data=train.NPS )
#print(QDA.fit)

#confusionMatrix(test.NPS$desc.NPS, predict(QDA.fit, test.NPS))

```


## Test Modelo SVM

```{r SVM, echo=FALSE}
bootControl <- trainControl(method = "cv",
                            savePred=T)
svm.fit <- train(desc.NPS~., 
                 data= train.NPS, 
                 method = "svmRadial", tuneLength = 3, 
                 trControl = bootControl, scaled = F)

svm.fit

svm.fit$finalModel

confusionMatrix(train.NPS$desc.NPS, predict(svm.fit, train.NPS))
confusionMatrix(test.NPS$desc.NPS, predict(svm.fit, test.NPS))

```


```{r SVM Lineal, echo=FALSE}
bootControl <- trainControl(method = "cv",
                            savePred=T)
svm.fit <- train(desc.NPS ~., 
                 data= train.NPS, 
                 method = "svmLinear", tuneLength = 3, 
                 trControl = bootControl, scaled = F)

svm.fit

svm.fit$finalModel

confusionMatrix(train.NPS$desc.NPS, predict(svm.fit, train.NPS))
confusionMatrix(test.NPS$desc.NPS, predict(svm.fit, test.NPS))


```

## Test Modelo Random Forest

```{r RF, echo=FALSE}

bootControl <- trainControl(method = "cv", number = 4)
rf.fit <- train(desc.NPS ~., 
                 data= train.NPS, 
                method = "rf", tuneLength = 4, 
                trControl = bootControl, scaled = F, 
                do.trace = T, ntree = 100,
                importance=T)

rf.fit
rf.fit$finalModel

```


  - Realizamos un análisis de la importancia de las variables en cada modelo

```{r RF Imp Variables, echo=FALSE}
rfImp <- varImp(rf.fit, scale = F)
rfImp
```


## Test Modelo Redes Neuronales

```{r RN, echo=FALSE}

bootControl <- trainControl(method = "cv", number = 4)
nnet.fit <- train(desc.NPS ~., 
                 data= train.NPS, 
                 method = "nnet",
                 trControl = bootControl, scaled = T)

nnet.fit
nnet.fit$finalModel
plot(nnet.fit)
confusionMatrix(train.NPS$desc.NPS, predict(nnet.fit, train.NPS))
confusionMatrix(test.NPS$desc.NPS, predict(nnet.fit, test.NPS))


```

 - Realizamos un análisis de la importancia de las variables en cada modelo

```{r nn Imp Variables, echo=FALSE}
nnImp <- varImp(nnet.fit, scale = F)
nnImp
```
